# Auditing & Pentesting Android Apps

## Getting Started with Android Security Tooling

### What is Drozer?

[_drozer_](https://github.com/mwrlabs/drozer), aka. _Mercury_, is used to assess Android applications by discovering vulnerabilities and passing payloads of known vulnerabilities to your application. 

We'll be covering the basics of _drozer_, but you can learn more through this
[extensive user guide](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)

### If you're currently running macOS, continue below. If you're running a Linux distribution, thank you for making life easier. Collect 100 pts and continue to [Installing Drozer](#installing-drozer).

## Create a Linux VM

Installing _drozer_ on macOS is...a challenge. You'll likely get stuck in dependency hell. There are some handy guides for getting it running on macOS, including this [OWASP Mobile Security Testing Guide](https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05b-Basic-Security_Testing.html) which everyone should read.

Instead of dealing with this, we're going to spin up a Linux VM.

**★ Install VirtualBox for macOS by clicking [here](https://download.virtualbox.org/virtualbox/5.2.16/VirtualBox-5.2.16-123759-OSX.dmg)**.  

**★ Create a new virtual machine, setting the `type` to `Linux` and the Version to `Ubuntu`**

![](/img/Create_VM.png)

_(unless you have a preference for another Linux distro. We'll be using _Lubuntu_, a lighter-weight Ubuntu, in this workshop.)_

**★ Next, download the `Lubuntu` image [here](http://cdimage.ubuntu.com/lubuntu/releases/18.04/release/lubuntu-18.04.1-desktop-amd64.iso),**
 
_(unless you're running your VM on an older Mac, in which case you should checkout the `Lubuntu` downloads page [here](https://lubuntu.me/downloads/)_

Personally, my most-used Linux distro is [Kali](https://www.kali.org/), which is a "pen-testing and ethical hacking Linux distribution". If you want to spend more time learning about pen-testing and ethical hacking, I highly recommend it. For the purpose of this workshop, however, Lubuntu (or any other supported Linux distro should be fine).

**★ Bump up the memory size to allocate to the VM from the suggested 1024MB to ~8192MB.** Allocating too little RAM will result in a corrupted display when you try to install the image.

![](/img/Set_VM_Memory.png)

**★ Create a virtual hard disk with a minimum of 10 GB of space.** I tend to add a bit more, since I never know what else I may do with the VM in the future.

![](/img/Create_VM_HDD.png)

I also tend to select `Fixed size` hard disk file settings for my VMs because I care more about speed than being able to dynamically allocate additional space in the future.

![](/img/Fixed_Size_HDD.png)

**★ Select _Create_**

**Important!** Before opening the new VM, we have to update settings in its display. The latest Lubuntu release requires that you bump up the processing power of the VM before you can access a display that isn't wildly corrupted (ie, the same issue you'd experience with allocating too little RAM).

**★ Right-click on the VM and open settings.** Navigate to *Display* and update your settings as shown below:

![](/img/Right_Click_New_VM.png)

![](/img/Set_4_cores.png)

**★ Hit okay, and your settings will save.**

**★ Double click the new VM in the left-hand column.** Select your `Lubutunu` ISO and continue with the installation process.

![](/img/Lubuntu_startup.png)

##### Congratulations! You now have a virtual machine 🎉

### <a name="installing-drozer"></a>Installing Drozer 

[Download the Debian package here](https://github.com/mwrlabs/drozer/releases/download/2.4.4/drozer_2.4.4.deb)

`sudo apt install python` # Get python 2.7+

`sudo apt --fix-broken install` # Get all the python dependencies

![](/img/Install_Drozer.png)

`sudo dpkg -i drozer_2.x.x.deb`

```shell
sudo apt-apt-repository ppa:webupd8team/java
sudo apt-get update
sudo apt-get install oracle-java8-installer
```

**★ Install 32-bit libraries**

If you're using Ubuntu or anything else Debian, 
```shell
sudo apt-get install lib32ncurses5 lib32stdc++6
```

else, find the appropriate packages for your distro & install.

**★ Install the Android SDK CLI tools**

```shell
wget https://dl.google.com/android/repository/sdk-tools-linux-*.zip
mkdir android-sdk
mv sdk-tools-linux-*.zip android-sdk/
unzip sdk-tools-linux-*.zip
```

**★  Create a device**
```shell
sudo ./sdkmanager "system-images;android-25;google_apis;x86"
sudo ./sdkmanager --licenses
sudo ./avdmanager create avd -n foo -k "system-images;android-25;google_apis;x86"
```

## Setting Up Our Reversing Environment

The tools we'll be using today are very usable in macOS. However, for the sake of maintaining a bit of a "hackerbox", we're going to install them within our Linux VM.

### Install [Apktool](https://ibotpeaches.github.io/Apktool/install/)
 
Apktool is a handy application that allows us to decompile an APK and view the _SMALI_ files packaged within. Decompiling the app with Apktool will also allow us to view `AndroidManifest.xml` for a basic understanding of what an app is doing, as well as areas where permissions may be over-granted.

If you want to make changes to a decompiled application, you can use Apktool to re-build the app as well. We won't be doing that in today's workshop, but it's useful for future reversing projects. 

**★ Download a wrapper script & rename** 

```shell
wget https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool.bat
```

**★ Download the latest Apktool**
```shell
wget https://bitbucket.org/iBotPeaches/apktool/downloads/apktool_2.3.3.jar
mv apktool_2.3.3.jar apktool
```

**★ Move downloaded files to `bin`**
```shell
sudo mv apktool.jar /usr/local/bin
sudo mv apktool /usr/local/bin
sudo chmod +x /usr/local/bin/apktool.jar
sudo chmod +x /usr/local/bin/apktool
```

### Install [dex2jar](https://github.com/pxb1988/dex2jar)

Dex2Jar will allow us to convert `classes.dex`, the Dalvik Executable, to readable `.class` files. For ART apps where the dex files are converted to OAT files, we can still extract the `.dex` files and convert to `.class`. Once we have `.class` files for each of the, well, classes in the app, we'll use JD-GUI to view them.

```shell
git clone https://github.com/pxb1988/dex2jar.git
```

### Install [jd-gui](http://jd.benow.ca/)

As mentioned, JD-GUI will display the Java source code of our `.class` files. 

```shell
wget https://github.com/java-decompiler/jd-gui/releases/download/v1.4.0/jd-gui_1.4.0-0_all.deb
sudo dpkg -i jd-gui_x.x.x-x_all.deb 
```

### Decompiling the APK

We're going to use a little python script to automate this process, but you can certainly run all of the steps independently. Take a look at the python file to see how we're using the apps if you'd like. 

```shell
./reverse_apks.py [path-to-apk]
```

The resulting directory at `[path-to-apk` will have the .jar file we'll use to view the decompiled `classes.dex` file, along with the disassembled resources from running Apktool.

## Installing DiVA in an Emulator

**★ Start an emulator**
```shell
emulator -avd foo
```

**★ Install the APK**
```shell
adb install [path/to/apk]
```

## Intro to the DiVA Application

### Initial Assessment with Drozer

Drozer allows us to learn a fair bit about the application, simply by requesting package information.

**★ Find the package name**
```shell
dz> run app.package.list -f damn
```

**★ Using the returned package name, use `app.package.info` to learn some basic information about the DiVA app:**
```shell
dz> run app.package.info -a com.[package-name]
```

### Attack Surface Details

Drozer will also alert us to particular "attack surfaces" made accessible by the application. For example, exported IPCs, which can be troublesome since exported components can be accessed by other applications.

**★ Identify attack surfaces**
```shell
dz> run app.package.attacksurface com.[package-name]
```

What attack surfaces do you find? These may come in handy while auditing the _DiVA_ app challenges in the next section.

**★ Identify the exported components**
```shell
dz> run app.activity.info -a com.[package-name]
```

### Reading from ContentProviders

As we discussed in the "theory" section of the workshop, content providers can often leak sensitive information about a user. Drozer will share which content providers are exported, and whether there are any permissions required in order for another application to interact with them.

**★ Show Content Provider details**
```shell
dz> run app.provider.info -a com.[package-name]
```

When a database is used with a content provider, data leakage can become a valid concern. Drozer will allow us to scan a database content provider for potentially sensitive values and ways to circumvent DB security.

**★ Use the scanner module to retrieve accessible URIs**
```dz> run scanner.provider.finduris -a com.[package-name]
```

Given the URIs returned from scanning the content provider, we can attempt to query the URI and retrieve information from the database without requiring any of the security embedded within the app.

**★ Query the content URI**
```shell
dz> run app.provider.query content://URI --vertical
```

We can also check for potential SQL injection attacks by querying the same content URI.

**★ Test for potential SQL injection attacks**
```shell
dz> run app.provider.query content://URI --projection "'"
dz> run app.provider.query content://URI --selection "'"
```

You can replace the projection and selection parameters with other potential SQL injection attacks in order to retrieve error messages and table information. Eg. `--projection "* FROM SQLITE_MASTER WHERE type='table';--"`

### Testing ALL the things

Drozer will also just automatically test for common vulnerabilities, if preferred. 

**★ Auto-testing for Common Vulnerabilities**

```shell
dz> run scanner.provider.injection -a com.[package-name]
dz> run scanner.provider.traversal -a com.[package-name]
```

Drozer's user guide is a good introduction to its main capabilities. You can access it [here](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf). There are also a _multitude_ of other _drozer_ tutorials and walkthroughs out in the wild.

 
## Solving (some) DiVA App Challenges

### Insecure Logging

As we discussed in `Part 1` with Android Security Theory, over-zealous logging can leak sensitive information that becomes attainable to those who know where to look for it.

**★ Click on _1. Insecure Logging_ and enter some text in the text field**

**★ Click _Check Out_**

**★ In terminal, view the log for our emulated device**

```shell
adb logcat
```

You should see output similar to the following:

```shell
D/MobileDataStateTracker( 469): default: setPolicyDataEnable(enabled=true)

D/LightsService( 469): Excessive delay setting light: 86ms

D/dalvikvm( 1695): GC_CONCURRENT freed 136K, 6% free 3845K/4060K, paused 7ms+4ms, total 93ms

E/diva-log( 1695): Error while processing transaction with credit card: 0000000000

E/SoundPool( 469): error loading /system/media/audio/ui/Effect_Tick.ogg
```

As we can see, the information stored in the text field has been logged to the application. Why is this dangerous? With Android 4.0 (and earlier), any application that had the `READ_LOGS` permission could see any other application's log. This has since changed, but was an easy way for other applications to "steal" permissions from valid apps. Plus, any rooted Android device could still be vulnerable to this attack. Even with the changes to Android 4.1+, an attacker with a physical device could still access these logs with `adb`. Back in 2012, _Facebook_ had this vulnerability in their mobile application. Read more about that [here](http://blog.parse.com/2012/04/10/discovering-a-major-security-hole-in-facebooks-android-sdk/)

#### Can you find where the vulnerability is introduced in the code?

**★  Use JD-GUI to open the `.class` files 

### Hardcoding Issues

**★ Click _2. Hardcoding Issues - Part 1_

Here, we're being asked to enter some kind of `Vendor Key`. Presumably, this key is logged _somewhere_ in the application. 

**★ Open `HardcodeActivity.class` using JD-GUI. Do you see the hardcoded key somewhere?**

As expected, we can see the textField matched against an unencrypted string.

```java
if (((EditText)findViewById(2131492987)).getText().toString().equals(“vendorsecretkey”))
```


### Insecure Data Storage

### Input Validation Issue

### Access Control Issues

[Infosec Institute's Full DiVA Walkthrough](https://resources.infosecinstitute.com/cracking-damn-insecure-and-vulnerable-apps-diva-part-1/#gref)


