# Auditing & Pentesting Android Apps

## Getting Started with Android Security Tooling

### What is Drozer?

[_drozer_](https://github.com/mwrlabs/drozer), aka. _Mercury_, is used to assess Android applications by discovering vulnerabilities and passing payloads of known vulnerabilities to your application. 

We'll be covering the basics of _drozer_, but you can learn more through this
[extensive user guide](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)

### If you're currently running macOS, continue below. If you're running a Linux distribution, thank you for making life easier. Collect 100 pts and continue to [Installing Drozer](#installing-drozer).

## Create a Linux VM

Installing _drozer_ on macOS is...a challenge. You'll likely get stuck in dependency hell. There are some handy guides for getting it running on macOS, including this [OWASP Mobile Security Testing Guide](https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05b-Basic-Security_Testing.html) which everyone should read.

Instead of dealing with this, we're going to spin up a Linux VM.

**★ Download the `Lubuntu` image [here](http://cdimage.ubuntu.com/lubuntu/releases/18.04/release/lubuntu-18.04.1-desktop-amd64.iso),**

 _(unless you have a preference for another Linux distro. We'll be using _Lubuntu_, a lighter-weight Ubuntu, in this workshop.)_

_If you're running your VM on an older computer that may not be a 64-bit system, you should checkout the `Lubuntu` downloads page [here](https://lubuntu.me/downloads/).

Personally, my most-used Linux distro is [Kali](https://www.kali.org/), which is a "pen-testing and ethical hacking Linux distribution". If you want to spend more time learning about pen-testing and ethical hacking, I highly recommend it. For the purpose of this workshop, however, Lubuntu (or any other Debian-based Linux distro should be fine).

**★ Install VirtualBox for macOS by clicking [here](https://download.virtualbox.org/virtualbox/5.2.16/VirtualBox-5.2.16-123759-OSX.dmg)**.  

**★ Create a new virtual machine, setting the `type` to `Linux` and the Version to `Ubuntu`**

![](/img/Create_VM.png)


**★ Bump up the memory size to allocate to the VM from the suggested 1024MB to ~8192MB.** Allocating too little RAM will result in a corrupted display when you try to install the image.

![](/img/Set_VM_Memory.png)

**★ Create a virtual hard disk with a minimum of 10 GB of space.** I tend to add a bit more, since I never know what else I may do with the VM in the future.

![](/img/Create_VM_HDD.png)

I also tend to select `Fixed size` hard disk file settings for my VMs because I care more about speed than being able to dynamically allocate additional space in the future.

![](/img/Fixed_Size_HDD.png)

**★ Select _Create_**

**Important!** Before opening the new VM, we have to update settings in its display. The latest Lubuntu release requires that you bump up the processing power of the VM before you can access a display that isn't wildly corrupted (ie, the same issue you'd experience with allocating too little RAM).

**★ Right-click on the VM and open settings.** Navigate to _System_ and update your settings as shown below:

![](/img/Right_Click_New_VM.png)

![](/img/Set_4_cores.png)

**★ Hit okay, and your settings will save.**

**★ Double click the new VM in the left-hand column.** Select your `Lubutunu` ISO and continue with the installation process.

![](/img/Lubuntu_startup.png)

##### Congratulations! You now have a virtual machine 🎉

### <a name="installing-drozer"></a>Installing Drozer 

[Download the Debian package here](https://github.com/mwrlabs/drozer/releases/download/2.4.4/drozer_2.4.4.deb)

`sudo apt install python` # Get python 2.7+

`sudo apt --fix-broken install` # Get all the python dependencies

![](/img/Install_Drozer.png)

`sudo dpkg -i drozer_2.x.x.deb`

```shell
sudo add-apt-repository ppa:webupd8team/java
sudo apt-get update
sudo apt-get install oracle-java8-installer
```

**★ Install 32-bit libraries**

If you're using Ubuntu or anything else Debian, 
```shell
sudo apt-get install lib32ncurses5 lib32stdc++6
```

else, find the appropriate packages for your distro & install.

**★ Install the Android SDK CLI tools**

**If CLI tools don't work, there's always [Android Studio](https://developer.android.com/studio/#downloads)**

```shell
wget https://dl.google.com/android/repository/sdk-tools-linux-4333796.zip
mkdir android-sdk
mv sdk-tools-linux-4333796.zip android-sdk/
unzip sdk-tools-linux-*.zip
```

** Add these new paths to your...path
```
vim ~/.bash_profile
export ANDROID_HOME=<path>
export ANDROID_AVD_HOME=/root/.android/avd
```

**★  Create a device**
```shell
sudo ./sdkmanager "system-images;android-25;google_apis;x86"
sudo ./sdkmanager --licenses
sudo ./avdmanager create avd -n foo -k "system-images;android-25;google_apis;x86"
```

## Setting Up Our Reversing Environment

The tools we'll be using today are very usable in macOS. However, for the sake of maintaining a bit of a "hackerbox", we're going to install them within our Linux VM.

### Install [Apktool](https://ibotpeaches.github.io/Apktool/install/)
 
Apktool is a handy application that allows us to decompile an APK and view the _SMALI_ files packaged within. Decompiling the app with Apktool will also allow us to view `AndroidManifest.xml` for a basic understanding of what an app is doing, as well as areas where permissions may be over-granted.

If you want to make changes to a decompiled application, you can use Apktool to re-build the app as well. We won't be doing that in today's workshop, but it's useful for future reversing projects. 

**★ Download a wrapper script & rename** 

```shell
wget https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool.bat
```

**★ Download the latest Apktool**
```shell
wget https://bitbucket.org/iBotPeaches/apktool/downloads/apktool_2.3.3.jar
mv apktool_2.3.3.jar apktool
```

**★ Move downloaded files to `bin`**
```shell
sudo mv apktool.jar /usr/local/bin
sudo mv apktool /usr/local/bin
sudo chmod +x /usr/local/bin/apktool.jar
sudo chmod +x /usr/local/bin/apktool
```

### Install [dex2jar](https://github.com/pxb1988/dex2jar)

Dex2Jar will allow us to convert `classes.dex`, the Dalvik Executable, to readable `.class` files. For ART apps where the dex files are converted to OAT files, we can still extract the `.dex` files and convert to `.class`. Once we have `.class` files for each of the, well, classes in the app, we'll use JD-GUI to view them.

**Download from [here](https://sourceforge.net/projects/dex2jar/files/)** and unzip.

### Install [jd-gui](http://jd.benow.ca/)

As mentioned, JD-GUI will display the Java source code of our `.class` files. 

```shell
wget https://github.com/java-decompiler/jd-gui/releases/download/v1.4.0/jd-gui_1.4.0-0_all.deb
sudo dpkg -i jd-gui_x.x.x-x_all.deb 
```

### Decompiling the APK

We're going to use a little python script to automate this process, but you can certainly run all of the steps independently. Take a look at the python file to see how we're using the apps if you'd like. 

```shell
./reverse_apks.py [path-to-apk]
```

The resulting directory at `[path-to-apk` will have the .jar file we'll use to view the decompiled `classes.dex` file, along with the disassembled resources from running Apktool.

## Installing DiVA in an Emulator

**★ Start an emulator**
```shell
emulator -avd foo
```

**★ Download the DiVA APK**
You can find the packaged app [here](/app/diva-beta.apk).

**★ Install the APK**
```shell
adb install [path/to/apk]
```

## Intro to the DiVA Application

### Initial Assessment with Drozer

Drozer allows us to learn a fair bit about the application, simply by requesting package information.

**★ Find the package name**
```shell
dz> run app.package.list -f damn
```

**★ Using the returned package name, use `app.package.info` to learn some basic information about the DiVA app:**
```shell
dz> run app.package.info -a com.[package-name]
```

### Attack Surface Details

Drozer will also alert us to particular "attack surfaces" made accessible by the application. For example, exported IPCs, which can be troublesome since exported components can be accessed by other applications.

**★ Identify attack surfaces**
```shell
dz> run app.package.attacksurface com.[package-name]
```

What attack surfaces do you find? These may come in handy while auditing the _DiVA_ app challenges in the next section.

**★ Identify the exported components**
```shell
dz> run app.activity.info -a com.[package-name]
```

### Reading from ContentProviders

As we discussed in the "theory" section of the workshop, content providers can often leak sensitive information about a user. Drozer will share which content providers are exported, and whether there are any permissions required in order for another application to interact with them.

**★ Show Content Provider details**
```shell
dz> run app.provider.info -a com.[package-name]
```

When a database is used with a content provider, data leakage can become a valid concern. Drozer will allow us to scan a database content provider for potentially sensitive values and ways to circumvent DB security.

**★ Use the scanner module to retrieve accessible URIs**
```shell
dz> run scanner.provider.finduris -a com.[package-name]
```

Given the URIs returned from scanning the content provider, we can attempt to query the URI and retrieve information from the database without requiring any of the security embedded within the app.

**★ Query the content URI**
```shell
dz> run app.provider.query content://URI --vertical
```

We can also check for potential SQL injection attacks by querying the same content URI.

**★ Test for potential SQL injection attacks**
```shell
dz> run app.provider.query content://URI --projection "'"
dz> run app.provider.query content://URI --selection "'"
```

You can replace the projection and selection parameters with other potential SQL injection attacks in order to retrieve error messages and table information. Eg. `--projection "* FROM SQLITE_MASTER WHERE type='table';--"`

### Testing ALL the things

Drozer will also just automatically test for common vulnerabilities, if preferred. 

**★ Auto-testing for Common Vulnerabilities**

```shell
dz> run scanner.provider.injection -a com.[package-name]
dz> run scanner.provider.traversal -a com.[package-name]
```

Drozer's user guide is a good introduction to its main capabilities. You can access it [here](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf). There are also a _multitude_ of other _drozer_ tutorials and walkthroughs out in the wild.

 
## Solving (some) DiVA App Challenges

### Insecure Logging

As we discussed in `Part 1` with Android Security Theory, over-zealous logging can leak sensitive information that becomes attainable to those who know where to look for it.

**★ Click on _1. Insecure Logging_ and enter some text in the text field**

**★ Click _Check Out_**

**★ In terminal, view the log for our emulated device**

```shell
adb logcat
```

You should see output similar to the following:

```shell
D/MobileDataStateTracker( 469): default: setPolicyDataEnable(enabled=true)

D/LightsService( 469): Excessive delay setting light: 86ms

D/dalvikvm( 1695): GC_CONCURRENT freed 136K, 6% free 3845K/4060K, paused 7ms+4ms, total 93ms

E/diva-log( 1695): Error while processing transaction with credit card: 0000000000

E/SoundPool( 469): error loading /system/media/audio/ui/Effect_Tick.ogg
```

As we can see, the information stored in the text field has been logged to the application. Why is this dangerous? With Android 4.0 (and earlier), any application that had the `READ_LOGS` permission could see any other application's log. This has since changed, but was an easy way for other applications to "steal" permissions from valid apps. Plus, any rooted Android device could still be vulnerable to this attack. Even with the changes to Android 4.1+, an attacker with a physical device could still access these logs with `adb`. Back in 2012, _Facebook_ had this vulnerability in their mobile application. Read more about that [here](http://blog.parse.com/2012/04/10/discovering-a-major-security-hole-in-facebooks-android-sdk/)

#### Can you find where the vulnerability is introduced in the code?

**★  Use JD-GUI to open the `.class` files** 

### Hardcoding Issues

**★ Click _2. Hardcoding Issues - Part 1_**

Here, we're being asked to enter some kind of `Vendor Key`. Presumably, this key is logged _somewhere_ in the application. 

**★ Open `HardcodeActivity.class` using JD-GUI. Do you see the hardcoded key somewhere?**

As expected, we can see the textField matched against an unencrypted string.

```java
if (((EditText)findViewById(2131492987)).getText().toString().equals(“vendorsecretkey”))
```

### Insecure Data Storage

Next, we're going to look for vulnerabilities in the way sensitive information is stored within the application. We're going to jump to _Insecure Data Storage - Part 2_, since it covers SQL injection vulnerabilities.

**★ Enter data into the text fields**

Now we need to figure out what's happening with that data. We can use `JD-GUI` again to take a look at how the information we're passing is being stored.

**★ Open `InsecureDataStorage2Activity.class` (lol) in JD-GUI**

Do you see any issues with the data processing? 

**★ Access the `databases` directory in the application**
```shell
adb shell
cd /data/data/[package-name]
ls
```

Here, we can see that we have a databases directory alongside the `cache` and `shared_prefs directory`. Those will come in handy for subsequent challenges.

**★ Pull the database file from the emulator to your Linux VM and analyse**
```shell
cd databases
adb pull /data/data/<package-name>/databases/ids2
file ids2
```

Now that we know what kind of file we're dealing with, and that vulnerabilities are introduced in the way the data is stored to this SQLite3 file, let's try to dump the information.

**★ Dump the SQLite Database contents**
```shell
sqlite3 ids2
.tables
select * from myuser;
```

### MOAR SQL Injections! Input Validation Issues

Did _drozer_ tell you about this potential issue? Let's inject some SQL! 

**★ Click Input Validation Issues Part 1**

As we know, SQL injection issues arise when queries aren't validated and either give too much information about the structure of the database, and/or fully dump information you shouldn't have access to.

Let's see whether the textField handles weird characters.

**★ In the textField, type `'"` and view the log**
```
adb logcat
```

**★ Dump the entire database with a classic SQL injection query: 1' or '1' == '1'**

We're asking for user `'1'` since we know we're dealing with a SQLite database, and that users typically auto-increment starting from 1. Hopefully, this will return the admin credentials.

**★ Find the source of this vulnerability by opening `SQLInjectionActivity.class` in JD-GUI**

_Hint_, we discovered a related issue in a previous challenge.


### These are some pretty straight-forward vulnerabilties, and are meant to give an idea of how to start looking for vulnerabilities in your own application. The full list of DiVA challenges is pretty long, and we definitely recommend attempting to solve _all_ of them! If you get stuck and want some guidance, _Infosec Institute_ has a full solution guide here: [Infosec Institute's Full DiVA Walkthrough](https://resources.infosecinstitute.com/cracking-damn-insecure-and-vulnerable-apps-diva-part-1/#gref)


